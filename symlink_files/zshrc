#!/usr/local/bin/zsh

export ZSH="$HOME/.oh-my-zsh"
export VIM_LOCATION="/usr/local/Cellar/macvim/7.4-77/MacVim.app/Contents/MacOS/Vim"
export EDITOR="$VIM_LOCATION"
export ARCHFLAGS="-arch x86_64"
export HOMEBREW_CASK_OPTS="--appdir=/Applications"
export AWS_CREDENTIAL_FILE="~/.aws/credentials"
export HOST_ENV="development"
export HISTCONTROL=ignoreboth:erasedups

source "$ZSH/oh-my-zsh.sh"
source "$HOME/Dotfiles/tmuxinator.zsh"
setopt CORRECT

unsetopt inc_append_history
unsetopt share_history

# Enable vim mode in the shell
bindkey -v
bindkey kj vi-cmd-mode

function print_colors() {
  for code in {000..255}; do
    print -P -- "$code: %F{$code}$ZSH_SPECTRUM_TEXT%f"
  done
}

# --------------------------------------------------------
#                TERMINAL PROMPT
# --------------------------------------------------------

autoload -U colors && colors

GOOD_EXIT_STATUS_COLOR=%F{154}
BAD_EXIT_STATUS_COLOR=%F{197}
WORKING_DIRECTORY_COLOR=%F{159}
GIT_BRANCH_COLOR=%F{213}


# Detect if git is initialized in this directory
function is_git_branch() {
  [[ -n "$(git status -s 2> /dev/null)" ]] && echo true
}

# Find the current git branch, if any
function git_branch() {
  echo "$(git branch 2>/dev/null| sed -n '/^\*/s/^\* //p')"
}

# Show return code of last command
function exit_status(){
if [ $? -eq 0 ]
  then
     echo -e "${GOOD_EXIT_STATUS_COLOR}\xE2\x9C\x93%{$reset_color%}"
  else
    echo -e "${BAD_EXIT_STATUS_COLOR}${$?}${NONE}"
  fi
}

# Show the current working directory
function working_directory() {
  echo "${WORKING_DIRECTORY_COLOR}%~%{$reset_color%}"
}


# Show the current git branch, if any
function git_prompt() {
  echo "$GIT_BRANCH_COLOR$(git_branch)%{$reset_color%}"
}

# Show if there are upstream changes
function up_stream() {
  behind=$(command git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l)
  if [ $behind -gt 0 ]
  then
    echo "%F{226}↑%{$reset_color%}"
  fi
}

# Show if there are downstream changes
function down_stream() {
  ahead=$(command git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l)

  if [ $ahead -gt 0 ]
  then
    echo "%F{226}↓%{$reset_color%}"
  fi
}

# Show if there are changes to be committed.
function parse_git_dirty() {
  if [[ $(is_git_branch) == true ]] && ! command git diff-index --quiet HEAD 2> /dev/null; then
    echo "%F{196}●%{$reset_color%}"
  fi
}

# Show the orange arrows
function arrow() {
  echo "%F{202}❯%F{208}❯%F{214}❯%{$reset_color%}"
}


# Show if currently in vim mode
vim_ins_mode=""
vim_cmd_mode="%F{221}[vim-mode] %{$reset_color%}"
vim_mode=$vim_ins_mode

function zle-keymap-select {
  vim_mode="${${KEYMAP/vicmd/${vim_cmd_mode}}/(main|viins)/${vim_ins_mode}}"
  zle reset-prompt
}
zle -N zle-keymap-select

function zle-line-finish {
  vim_mode=$vim_ins_mode
}
zle -N zle-line-finish

# Fix a bug when you C-c in CMD mode and you'd be prompted with CMD mode
# indicator, while in fact you would be in INS mode Fixed by catching SIGINT
# (C-c), set vim_mode to INS and then repropagate the SIGINT, so if anything
# else depends on it, we will not break it Thanks Ron! (see comments)
function TRAPINT() {
  vim_mode=$vim_ins_mode
  return $(( 128 + $1 ))
}

zle -N zle-line-init
zle -N zle-keymap-select
export KEYTIMEOUT=60


# Generate prompt
PS1='
$(exit_status) $(working_directory) $(git_prompt) $(parse_git_dirty)$(up_stream)$(down_stream)${vim_mode}
$(arrow) '


# --------------------------------------------------------
#                ALIASES
# --------------------------------------------------------

# LS SHORTCUTS
alias ls="ls -G"
alias la="ls -A"
alias ll="ls -l -h"
alias lla="ls -al"
alias lal="ls -al"
alias lh="ls -d .??*"
alias llh="ls -ld -h  .??*"
alias lhl="ls -ld -h .??*"
alias ld="ls -d */" # Show directories
alias lg="ls | grep"
alias le="find . -maxdepth 1  -type f -perm -u=x" # Show executables
alias lf="ls | egrep -v '^d'"
alias clr="clear"

# NAV SHORTCUTS
alias dl="cd ~/Downloads"
alias vbundle="cd ~/.vim/bundle"
alias lello="cd ~/lello"
alias pulp="cd ~/pulp"
alias spine="cd ~/spine"
alias spiel="cd ~/spiel"
alias forklift="cd ~/forklift"

# GIT SHORTCUTS

# checkout
alias co="git checkout"
alias cob="git checkout -b"
alias cod="git branch -d"
alias codd="git branch -D"
alias col="git checkout -"

# push
alias push="git push"
alias pusho="git push origin "

# pull
alias pull="git pull"
alias pullo="git pull origin"

# commit
alias cmt="git commit -am"
alias amend="git commit -a --amend"
alias amendn="git commit -a --amend --no-edit"
alias wip="git commit -am 'WIP'"

# reset
function confirm_cmd() {
  echo -n "$1? [y/n]: "
  read answer

  if [ "$answer" = "y" ]
  then
    eval $2
  else
    echo "Aborting"
  fi
}

function undo() {
  git reset HEAD~${1-1} --mixed
}

function mirror() {
  branch=""
  if [ ! -z $1 ]
  then
    branch="$1"
  else
    branch="$(git_branch)"
  fi
  confirm_cmd "Are you sure you want to reset --hard to remote branch $branch" "git fetch; git reset --hard origin/$branch"
}

function wipe() {
  confirm_cmd "Are you sure you want to wipe your changes" "git add -A; git commit -qm 'WIPE SAVEPOINT'; git reset HEAD~${1-1} --hard"
}

function gclean() {
  git checkout master
  if [ $? -eq 0 ]
  then
    git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs git branch -d;
  fi
}


# status
alias cubr="git branch"
alias stat="git status"
alias pstat="git status -s"
alias log="git log --graph"
alias logo="git log --graph --oneline"
alias gls="log --pretty=format:\"%C(yellow)%h %Creset%s%Cblue [%cn]\" --decorate"
alias gll="log --pretty=format:\"%C(yellow)%h%Cred%d\\ %Creset%s%Cblue\\ [%cn]\" --decorate --numstat"

alias diff="git diff"
alias cherry="git cherry -v"

# rebase
alias gm="git checkout master && git pull origin master"
alias rem="git rebase -i master"
function re() {
  git rebase -i HEAD~${1-1}
}

# MISCELLENEOUS SHORTCUTS
alias unsu="sudo -k;"
alias su="sudo -s"
alias sub="/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl"
alias src="source ~/.zshrc"
alias m="make"
alias app="cd /Applications"
alias serv="python -m SimpleHTTPServer 8000"
alias editcron="env EDITOR=vim crontab -e"
alias mem="top -l 1 | ag Phys"
alias notifyDone='reattach-to-user-namespace terminal-notifier -title "Codemang" -message "Done with task!"'

# VIM
alias vim="$VIM_LOCATION"
alias v="vim"
alias vimrc="vim ~/.vimrc"
alias zpref="vim ~/.zshrc"
alias vtree="vim -c ':CommandT'"
alias vnerd="vim -c ':NERDTree'"

# BOOKBUB
alias sshs='ssh bookbub-staging'
alias sshp='ssh bookbub-production'
alias slog='ssh -N stage-tunnel'
alias plog='ssh -N prod-tunnel'

# RAILS
alias mig="bin/rake db:migrate"
alias prep="bin/rake db:test:prepare"

# VAGRANT
alias vup="vagrant up"
alias vdest="vagrant destroy"
alias vssh="vagrant ssh"
alias vprov="vagrant provision"

# TMUX
alias tn="tmux new -s"
alias ta="tmux attach -t"
alias tpref="vim ~/.tmux.conf"
alias tsource="tmux source-file /Users/codemang/.tmux.conf"
alias tls="tmux list-sessions"
alias ts="tmux switch -t"
alias td="tmux detach"
alias tk="tmux kill-session -t"


source "$HOME/.fzf.zsh"
export FZF_COMPLETION_TRIGGER=',,'
export FZF_DEFAULT_COMMAND='ag -g ""'

# Toggle between vim and shell with ctrl-z
fancy-ctrl-z () {
  if [[ $#BUFFER -eq 0 ]]; then
    BUFFER="fg"
    zle accept-line
  else
    zle push-input
    zle clear-screen
  fi
}
zle -N fancy-ctrl-z
bindkey '^Z' fancy-ctrl-z

export LD_BIND_NOW=1
export CLICOLOR=1
export LSCOLORS=gxBxhxDxfxhxhxhxhxcxcx
